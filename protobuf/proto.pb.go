// Code generated by protoc-gen-go. DO NOT EDIT.
// source: warp.proto

/*
Package warp is a generated protocol buffer package.

It is generated from these files:
	warp.proto

It has these top-level messages:
	Empty
	Message
	SubscribeRequest
	Request
	Response
*/
package protobuf

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Message struct {
	Channel  string `protobuf:"bytes,1,opt,name=Channel" json:"Channel,omitempty"`
	Metadata string `protobuf:"bytes,2,opt,name=Metadata" json:"Metadata,omitempty"`
	Body     []byte `protobuf:"bytes,3,opt,name=Body,proto3" json:"Body,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Message) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Message) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Message) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type SubscribeRequest struct {
	Channel string `protobuf:"bytes,1,opt,name=Channel" json:"Channel,omitempty"`
	Group   string `protobuf:"bytes,2,opt,name=Group" json:"Group,omitempty"`
}

func (m *SubscribeRequest) Reset()                    { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()               {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SubscribeRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *SubscribeRequest) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

type Request struct {
	ID           string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Channel      string `protobuf:"bytes,2,opt,name=Channel" json:"Channel,omitempty"`
	Metadata     string `protobuf:"bytes,3,opt,name=Metadata" json:"Metadata,omitempty"`
	Body         []byte `protobuf:"bytes,4,opt,name=Body,proto3" json:"Body,omitempty"`
	ReplyChannel string `protobuf:"bytes,5,opt,name=ReplyChannel" json:"ReplyChannel,omitempty"`
	Timeout      int32  `protobuf:"varint,6,opt,name=Timeout" json:"Timeout,omitempty"`
	CacheKey     string `protobuf:"bytes,7,opt,name=CacheKey" json:"CacheKey,omitempty"`
	CacheTTL     int32  `protobuf:"varint,8,opt,name=CacheTTL" json:"CacheTTL,omitempty"`
	Context      []byte `protobuf:"bytes,9,opt,name=Context,proto3" json:"Context,omitempty"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Request) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Request) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Request) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Request) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Request) GetReplyChannel() string {
	if m != nil {
		return m.ReplyChannel
	}
	return ""
}

func (m *Request) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *Request) GetCacheKey() string {
	if m != nil {
		return m.CacheKey
	}
	return ""
}

func (m *Request) GetCacheTTL() int32 {
	if m != nil {
		return m.CacheTTL
	}
	return 0
}

func (m *Request) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

type Response struct {
	RequestID    string `protobuf:"bytes,1,opt,name=RequestID" json:"RequestID,omitempty"`
	ReplyChannel string `protobuf:"bytes,2,opt,name=ReplyChannel" json:"ReplyChannel,omitempty"`
	Metadata     string `protobuf:"bytes,3,opt,name=Metadata" json:"Metadata,omitempty"`
	Body         []byte `protobuf:"bytes,4,opt,name=Body,proto3" json:"Body,omitempty"`
	ChachHit     bool   `protobuf:"varint,5,opt,name=ChachHit" json:"ChachHit,omitempty"`
	Context      []byte `protobuf:"bytes,6,opt,name=Context,proto3" json:"Context,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Response) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *Response) GetReplyChannel() string {
	if m != nil {
		return m.ReplyChannel
	}
	return ""
}

func (m *Response) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Response) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Response) GetChachHit() bool {
	if m != nil {
		return m.ChachHit
	}
	return false
}

func (m *Response) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func init() {
	proto.RegisterType((*Empty)(nil), "warp.Empty")
	proto.RegisterType((*Message)(nil), "warp.Message")
	proto.RegisterType((*SubscribeRequest)(nil), "warp.SubscribeRequest")
	proto.RegisterType((*Request)(nil), "warp.Request")
	proto.RegisterType((*Response)(nil), "warp.Response")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Warp service

type WarpClient interface {
	// SendMessage - publish single message
	// Metadata Paramters:
	// client_tag - a string that represent the client connection
	// message_timeout - Optional, set timeout in millisecnd for verification of delivery
	SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Empty, error)
	// SendMessageStream - publish constant stream of pub Message
	// Metadata Paramters:
	// client_tag - a string that represent the client connection
	SendMessageStream(ctx context.Context, opts ...grpc.CallOption) (Warp_SendMessageStreamClient, error)
	// SubscribeToChannel - listening to pub messages
	// Metadata Paramters:
	// client_tag - a string that represent the client connection
	SubscribeToChannel(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (Warp_SubscribeToChannelClient, error)
	// SendRequest - sending request with timeout
	// Metadata Paramters:
	// client_tag - a string that represent the client connection
	SendRequest(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	// SendResponse - sending single response in case a client cannot support bi-di streaming
	// Metadata Paramters:
	// client_tag - a string that represent the client connection
	SendResponse(ctx context.Context, in *Response, opts ...grpc.CallOption) (*Empty, error)
	// RequestResponseStream - bi-di streams of getting request / sending replies
	// Metadata Paramters:
	// client_tag - a string that represent the client connection
	// channel - the channel we subscribe for getting requests
	// group - the gropu we subscirbe for getting requests
	RequestResponseStream(ctx context.Context, opts ...grpc.CallOption) (Warp_RequestResponseStreamClient, error)
}

type warpClient struct {
	cc *grpc.ClientConn
}

func NewWarpClient(cc *grpc.ClientConn) WarpClient {
	return &warpClient{cc}
}

func (c *warpClient) SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/warp.warp/SendMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *warpClient) SendMessageStream(ctx context.Context, opts ...grpc.CallOption) (Warp_SendMessageStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Warp_serviceDesc.Streams[0], c.cc, "/warp.warp/SendMessageStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &warpSendMessageStreamClient{stream}
	return x, nil
}

type Warp_SendMessageStreamClient interface {
	Send(*Message) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type warpSendMessageStreamClient struct {
	grpc.ClientStream
}

func (x *warpSendMessageStreamClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *warpSendMessageStreamClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *warpClient) SubscribeToChannel(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (Warp_SubscribeToChannelClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Warp_serviceDesc.Streams[1], c.cc, "/warp.warp/SubscribeToChannel", opts...)
	if err != nil {
		return nil, err
	}
	x := &warpSubscribeToChannelClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Warp_SubscribeToChannelClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type warpSubscribeToChannelClient struct {
	grpc.ClientStream
}

func (x *warpSubscribeToChannelClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *warpClient) SendRequest(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/warp.warp/SendRequest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *warpClient) SendResponse(ctx context.Context, in *Response, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/warp.warp/SendResponse", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *warpClient) RequestResponseStream(ctx context.Context, opts ...grpc.CallOption) (Warp_RequestResponseStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Warp_serviceDesc.Streams[2], c.cc, "/warp.warp/RequestResponseStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &warpRequestResponseStreamClient{stream}
	return x, nil
}

type Warp_RequestResponseStreamClient interface {
	Send(*Response) error
	Recv() (*Request, error)
	grpc.ClientStream
}

type warpRequestResponseStreamClient struct {
	grpc.ClientStream
}

func (x *warpRequestResponseStreamClient) Send(m *Response) error {
	return x.ClientStream.SendMsg(m)
}

func (x *warpRequestResponseStreamClient) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Warp service

type WarpServer interface {
	// SendMessage - publish single message
	// Metadata Paramters:
	// client_tag - a string that represent the client connection
	// message_timeout - Optional, set timeout in millisecnd for verification of delivery
	SendMessage(context.Context, *Message) (*Empty, error)
	// SendMessageStream - publish constant stream of pub Message
	// Metadata Paramters:
	// client_tag - a string that represent the client connection
	SendMessageStream(Warp_SendMessageStreamServer) error
	// SubscribeToChannel - listening to pub messages
	// Metadata Paramters:
	// client_tag - a string that represent the client connection
	SubscribeToChannel(*SubscribeRequest, Warp_SubscribeToChannelServer) error
	// SendRequest - sending request with timeout
	// Metadata Paramters:
	// client_tag - a string that represent the client connection
	SendRequest(context.Context, *Request) (*Response, error)
	// SendResponse - sending single response in case a client cannot support bi-di streaming
	// Metadata Paramters:
	// client_tag - a string that represent the client connection
	SendResponse(context.Context, *Response) (*Empty, error)
	// RequestResponseStream - bi-di streams of getting request / sending replies
	// Metadata Paramters:
	// client_tag - a string that represent the client connection
	// channel - the channel we subscribe for getting requests
	// group - the gropu we subscirbe for getting requests
	RequestResponseStream(Warp_RequestResponseStreamServer) error
}

func RegisterWarpServer(s *grpc.Server, srv WarpServer) {
	s.RegisterService(&_Warp_serviceDesc, srv)
}

func _Warp_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WarpServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/warp.warp/SendMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WarpServer).SendMessage(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _Warp_SendMessageStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WarpServer).SendMessageStream(&warpSendMessageStreamServer{stream})
}

type Warp_SendMessageStreamServer interface {
	SendAndClose(*Empty) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type warpSendMessageStreamServer struct {
	grpc.ServerStream
}

func (x *warpSendMessageStreamServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *warpSendMessageStreamServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Warp_SubscribeToChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WarpServer).SubscribeToChannel(m, &warpSubscribeToChannelServer{stream})
}

type Warp_SubscribeToChannelServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type warpSubscribeToChannelServer struct {
	grpc.ServerStream
}

func (x *warpSubscribeToChannelServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _Warp_SendRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WarpServer).SendRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/warp.warp/SendRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WarpServer).SendRequest(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Warp_SendResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WarpServer).SendResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/warp.warp/SendResponse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WarpServer).SendResponse(ctx, req.(*Response))
	}
	return interceptor(ctx, in, info, handler)
}

func _Warp_RequestResponseStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WarpServer).RequestResponseStream(&warpRequestResponseStreamServer{stream})
}

type Warp_RequestResponseStreamServer interface {
	Send(*Request) error
	Recv() (*Response, error)
	grpc.ServerStream
}

type warpRequestResponseStreamServer struct {
	grpc.ServerStream
}

func (x *warpRequestResponseStreamServer) Send(m *Request) error {
	return x.ServerStream.SendMsg(m)
}

func (x *warpRequestResponseStreamServer) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Warp_serviceDesc = grpc.ServiceDesc{
	ServiceName: "warp.warp",
	HandlerType: (*WarpServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendMessage",
			Handler:    _Warp_SendMessage_Handler,
		},
		{
			MethodName: "SendRequest",
			Handler:    _Warp_SendRequest_Handler,
		},
		{
			MethodName: "SendResponse",
			Handler:    _Warp_SendResponse_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendMessageStream",
			Handler:       _Warp_SendMessageStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeToChannel",
			Handler:       _Warp_SubscribeToChannel_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RequestResponseStream",
			Handler:       _Warp_RequestResponseStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "warp.proto",
}

func init() { proto.RegisterFile("warp.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 430 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xcd, 0xba, 0x49, 0x9c, 0x4c, 0x43, 0x05, 0x2b, 0x8a, 0x56, 0x11, 0x87, 0x68, 0x4f, 0x91,
	0x10, 0x56, 0x45, 0xaf, 0x48, 0x48, 0x69, 0x51, 0xa9, 0xa0, 0x17, 0xdb, 0x12, 0xe7, 0x8d, 0x3d,
	0xc2, 0x91, 0x1a, 0xaf, 0xb1, 0xd7, 0x02, 0xff, 0x25, 0x8e, 0xfc, 0x08, 0xfe, 0x10, 0x7f, 0x00,
	0x79, 0x3f, 0xdc, 0xd8, 0xd0, 0x48, 0xdc, 0xfc, 0x76, 0xe7, 0xbd, 0x79, 0x33, 0xfb, 0x0c, 0xf0,
	0x4d, 0x94, 0x45, 0x50, 0x94, 0x52, 0x49, 0x3a, 0x6e, 0xbf, 0xb9, 0x0f, 0x93, 0xf7, 0xfb, 0x42,
	0x35, 0x3c, 0x02, 0xff, 0x0e, 0xab, 0x4a, 0x7c, 0x41, 0xca, 0xc0, 0xbf, 0xca, 0x44, 0x9e, 0xe3,
	0x3d, 0x23, 0x2b, 0xb2, 0x9e, 0x87, 0x0e, 0xd2, 0x25, 0xcc, 0xee, 0x50, 0x89, 0x54, 0x28, 0xc1,
	0x3c, 0x7d, 0xd5, 0x61, 0x4a, 0x61, 0xbc, 0x91, 0x69, 0xc3, 0x4e, 0x56, 0x64, 0xbd, 0x08, 0xf5,
	0x37, 0xdf, 0xc0, 0xd3, 0xa8, 0xde, 0x56, 0x49, 0xb9, 0xdb, 0x62, 0x88, 0x5f, 0x6b, 0xac, 0xd4,
	0x11, 0xf5, 0xe7, 0x30, 0xb9, 0x29, 0x65, 0x5d, 0x58, 0x69, 0x03, 0xf8, 0x6f, 0x02, 0xbe, 0xe3,
	0x9e, 0x81, 0x77, 0x7b, 0x6d, 0x69, 0xde, 0xed, 0xf5, 0xa1, 0x96, 0xf7, 0xb8, 0xd3, 0x93, 0x47,
	0x9c, 0x8e, 0x1f, 0x9c, 0x52, 0x0e, 0x8b, 0x10, 0x8b, 0xfb, 0xc6, 0xc9, 0x4d, 0x34, 0xa7, 0x77,
	0xd6, 0x76, 0x8b, 0x77, 0x7b, 0x94, 0xb5, 0x62, 0xd3, 0x15, 0x59, 0x4f, 0x42, 0x07, 0xdb, 0x6e,
	0x57, 0x22, 0xc9, 0xf0, 0x23, 0x36, 0xcc, 0x37, 0xdd, 0x1c, 0xee, 0xee, 0xe2, 0xf8, 0x13, 0x9b,
	0x69, 0x5a, 0x87, 0xb5, 0x7f, 0x99, 0x2b, 0xfc, 0xae, 0xd8, 0x5c, 0x9b, 0x71, 0x90, 0xff, 0x24,
	0x30, 0x0b, 0xb1, 0x2a, 0x64, 0x5e, 0x21, 0x7d, 0x09, 0x73, 0xbb, 0x81, 0x6e, 0xfa, 0x87, 0x83,
	0xbf, 0xac, 0x7b, 0xff, 0xb0, 0xfe, 0xbf, 0xeb, 0x68, 0x4d, 0x67, 0x22, 0xc9, 0x3e, 0xec, 0x94,
	0x5e, 0xc5, 0x2c, 0xec, 0xf0, 0xa1, 0xe9, 0x69, 0xcf, 0xf4, 0x9b, 0x5f, 0x1e, 0xe8, 0x54, 0xd1,
	0x57, 0x70, 0x1a, 0x61, 0x9e, 0xba, 0x40, 0x3d, 0x09, 0x74, 0xee, 0x2c, 0x5c, 0x9e, 0x1a, 0x68,
	0x72, 0x37, 0xa2, 0x97, 0xf0, 0xec, 0xa0, 0x38, 0x52, 0x25, 0x8a, 0xfd, 0x71, 0xca, 0x9a, 0xd0,
	0x77, 0x40, 0xbb, 0x64, 0xc5, 0xd2, 0x8d, 0xf9, 0xc2, 0x94, 0x0d, 0x33, 0xb7, 0xec, 0xab, 0xf1,
	0xd1, 0x05, 0xa1, 0x81, 0xb1, 0xe8, 0x92, 0x65, 0x2b, 0x1c, 0xe1, 0xcc, 0x41, 0xf3, 0x02, 0x7c,
	0x44, 0x5f, 0xc3, 0xc2, 0xd4, 0xdb, 0x37, 0x19, 0x54, 0x0c, 0x87, 0x7a, 0x0b, 0xe7, 0x56, 0xcb,
	0x55, 0xd8, 0xc1, 0x86, 0xbc, 0x7e, 0xe3, 0x76, 0xb6, 0x0b, 0xb2, 0x39, 0xff, 0xe1, 0xd1, 0xb8,
	0x14, 0x29, 0xe6, 0x49, 0x13, 0x7c, 0x6e, 0xef, 0x6f, 0xca, 0x22, 0xd9, 0x4e, 0xf5, 0x9f, 0x7b,
	0xf9, 0x27, 0x00, 0x00, 0xff, 0xff, 0x72, 0xa3, 0x8f, 0xb8, 0xc7, 0x03, 0x00, 0x00,
}
